/*!
\page bjam
  Command-line utility to build Boost-related C++ projects with Boost.Build

\section sec_synopsis SYNOPSIS

<b>bjam</b> <tt>[-a] [-dx] [-fx] [-jx] [-lx] [-n] [-ox] [-px] [-q] [-sx=y] [-tx] [-v] [--x]</tt>

 \e bjam accepts the following options:

 \b -a<br>
   Build all targets, even if they are current

 \b -dx<br>
   Set the debug level to x (0-9)

 \b -fx<br>
    Read x instead of Jambase

 \b -jx<br>
    Run up to x shell commands concurrently

 \b -lx<br>
    Limit actions to x number of seconds after which they are stopped

 \b -n<br>
    Don't actually execute the updating actions

 \b -ox<br>
    Write the updating actions to file x

 \b -px<br>
    x=0, pipes action stdout and stderr merged into action output

 \b -q<br>
    Quit quickly as soon as a target fails

 \b -sx=y<br>
    Set variable x=y, overriding environment

 \b -tx<br>
    Rebuild x, even if it is up-to-date

 \b -v<br>
    Print the version of jam and exit

 \b --x<br>
    Option is ignored

\section sec_description DESCRIPTION

 This section provides the information necessary to create your
 own projects using \e Boost::Build
 The information provided here is relatively high-level, and Chapter
 6, Reference as well as the on-line help system must be used to
 obtain low-level documentation (see --help)

 \e Boost::Build actually consists of two parts -
 \e Boost::Jam, a build engine with its own interpreted language,
 and \e Boost::Build itself, implemented in \e Boost::Jam's
 language. The chain of events when you type bjam on the command line
 is as follows:
 - \e Boost::Jam tries to find \e Boost::Build and loads the top-level
 module. The exact process is described in the section called
 “Initialization”

 - The top-level module loads user-defined configuration files,
 \e user-config.jam and \e site-config.jam, which define
 available toolsets

 - The \e Jamfile in the current directory is read
 That in turn might cause reading of further Jamfiles.
 As a result, a tree of projects is created, with targets inside
 projects

 - Finally, using the build request specified on the command line, \e
 Boost::Build decides which targets should be built and how. That
 information is passed back to \e Boost::Jam, which takes care of
 actually running the scheduled build action commands

 So, to be able to successfully use \e Boost::Build, you need to know
 only four things:
 - How to configure \e Boost::Build (http://www.boost.org/boost-build2/doc/html/bbv2/overview/configuration.html)
 - How to declare targets in Jamfiles (http://www.boost.org/boost-build2/doc/html/bbv2/overview/targets.html)
 - How the build process works (http://www.boost.org/boost-build2/doc/html/bbv2/overview/build_process.html)

 Some Basics about the \e Boost::Jam language. See the section called
 “Boost::Jam Language” (http://www.boost.org/boost-build2/doc/html/bbv2/overview/jam_language.html)

\section sec_concepts CONCEPTS

 \e Boost::Build has a few unique concepts that are introduced
 in this section. The best way to explain the concepts is by
 comparison with more classical build tools

 When using any flavour of make, you directly specify targets and
 commands that are used to create them from other target. The below
 example creates a.o from a.c using a hardcoded compiler invocation
 command

a.o: a.c<br>
 g++ -o a.o -g a.c

 This is rather low-level description mechanism and it is hard to
 adjust commands, options, and sets of created targets depending on
 the used compiler and operating system.

 To improve portability, most modern build system provide a set of
 higher-level functions that can be used in build description
 files. Consider this example:

add_program ("a", "a.c")<br>

 This is a function call that creates targets necessary to create
 executable file from source file a.c. Depending on configured
 properties, different commands line may be used. However, \e add_program
 is higher-level, but rather thin level All targets are created
 immediately when build description is parsed, which makes it
 impossible to perform multi-variant builds. Often, change in any
 build property requires complete reconfiguration of the build tree

 In order to support true multivariant builds, Boost::Build
 introduces the concept of metatarget—object that is created when
 build description is parsed and can be later called with specific
 build properties to generate actual targets

 Consider an example:

exe a : a.cpp ;<br>

 When this declaration is parsed, \e Boost::Build creates a metatarget,
 but does not yet decides what files must be created, or what commands
 must be used. After all build files are parsed, Boost::Build considers
 properties requested on the command line. Supposed you have invoked
 \e Boost::Build with:

 \e bjam toolset=gcc toolset=msvc<br>

 In that case, the metatarget will be called twice, once with
 toolset=gcc and once with toolset=msvc. Both invocations will
 produce concrete targets, that will have different extensions and use
 different command lines. Another key concept is build
 property. Build property is a variable that affects the build
 process. It can be specified on the command line, and is passed when
 calling a metatarget

 While all build tools have a similar mechanism, \e Boost::Build differs
 by requiring that all build properties are declared in advance, and
 providing a large set of properties with portable semantics

 The final concept is property propagation. Boost::Build does not
 require that every metatarget is called with the same
 properties. Instead, the "top-level" metatargets are called with the
 properties specified on the command line
 Each metatarget can elect to augment or override some properties (in
 particular, using the requirements mechanism, see the section called
 “Requirements”:
 http://www.boost.org/boost-build2/doc/html/bbv2/overview/targets.html#bbv2.overview.targets.requirements)
 Then, the dependency metatargets are called with modified properties
 and produce concrete targets that are then used in build process
 Of course, dependency metatargets maybe in turn modify build
 properties and have dependencies of their own.

 For more in-depth treatment of the requirements and concepts, you
 may refer to SYRCoSE 2009 Boost::Build article
 (http://syrcose.ispras.ru/2009/files/04_paper.pdf).

\section sec_see_also SEE ALSO
  \b boost-libraries(3)

\section sec_support SUPPORT
  Please report any bugs to https://svn.boost.org/trac/boost/

\section sec_copyright COPYRIGHT

 Boost Software License - Version 1.0 - August 17th, 2003

 See the LICENSE_1_0.txt file for more information on that license,
 or directly on Internet:<br> http://www.boost.org/LICENSE_1_0.txt

*/
